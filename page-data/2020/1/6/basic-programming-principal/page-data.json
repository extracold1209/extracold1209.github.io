{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/2020/1/6/basic-programming-principal","result":{"data":{"content":{"edges":[{"node":{"id":"2aab578d-1616-52bb-bb81-9cf3577cc077","html":"<p>나는 개발을 하면서 몇가지 꼭 혼자서 지키고자 노력하는 원칙이 있다.</p>\n<ul>\n<li>하나의 메소드는 15~20 줄이 넘어가지 않도록 하자.</li>\n<li>세번의 반복로직은 하나의 함수로</li>\n<li>인자는 모델 객체로 받거나, 3~4 개 이상을 넘어가면 안된다.</li>\n</ul>\n<p>이런 원칙들은 자바 개발을 기준으로 객체지향적 개발 방식을 공부하면서 몸에 밴 몇가지 원칙이다.</p>\n<p>나는 이슈를 처리하기 위해 건드렸던 다른 코드들도 웬만해서 내가 지나가면 리팩토링을 하는 편이다.<br>\n<del>리팩토링으로 다른 이슈가 나는 건 다른 문제</del></p>\n<hr>\n<p>실무 개발을 진행하다보면, 이슈가 급하다거나, 레거시 코드에 대한 이해부족 내지는 건들고 싶지 않다는 생각에 기존 코드를 건드리지 않고 급한 불만 끄는 느낌의 코딩을 자주 하게 된다.<br>\n깨끗하고 깔끔하고 사람이 읽기 편한 코드를 짜야한다는 것은 다 알고는 있지만, 실천하기 힘든 것이 현실이다.</p>\n<p>이슈가 급해서 빨리 처리해야하거나, 레거시 코드에 대한 이해부족 내지는 도저히 건들 수준이 아닌 코드인 경우가 그렇다.</p>\n<p>물론.. 내가 짠 코드가 언제나 좋다고 할 순 없다. <code>어떤 놈이 이렇게 짰어 = 과거의 나</code> 인 경우도 굉장히 많기 때문이다..</p>\n<p>그렇다고 에이 뭐 얼마나 개발하겠다고, 아니면 그냥 지금 당장만 처리하고 나중에는 모르겠다 하는 식의 발전없는 마인드를 가지고 싶진 않다.</p>\n<p>그런 의미로 다시 기본적인 코드 작성 원칙을 되새겨보고자 글을 작성해 두도록 하겠다.</p>\n<blockquote>\n<p>참고<br>\n<a href=\"https://medium.com/@derodu/design-patterns-kiss-dry-tda-yagni-soc-828c112b89ee\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@derodu/design-patterns-kiss-dry-tda-yagni-soc-828c112b89ee</a><br>\n<a href=\"https://www.makeuseof.com/tag/basic-programming-principles/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.makeuseof.com/tag/basic-programming-principles/</a>\n<a href=\"https://engineering.linecorp.com/ko/blog/code-readability-vol1/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://engineering.linecorp.com/ko/blog/code-readability-vol1/</a></p>\n</blockquote>\n<hr>\n<h1 id=\"kiss-keep-it-simple-stupid\"><a href=\"#kiss-keep-it-simple-stupid\" aria-label=\"kiss keep it simple stupid permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>KISS (Keep It Simple Stupid)</h1>\n<p>이는 해석하는 사람마다 그 의의가 조금씩 다를 수 있겠다.<br>\n하지만 주요 골자는 <code>복잡하게 하지말고, 간단하게 정리하라</code> 정도로 볼 수 있을 것 같다.</p>\n<p>나의 경우에는 이렇게 생각한다.</p>\n<ul>\n<li>\n<p>추상화를 잘 하자. 또한 추상화를 했다면 함수명 하나만으로 기본적인 로직을 파악할 수 있어야 한다.</p>\n<ul>\n<li>예를 들어, getValue 라는 이름의 함수가 DB 에서 데이터를 가져오고, 다른 필드를 업데이트하며 UI에 이벤트를 발생시키는 짓은 말도안된다.</li>\n</ul>\n</li>\n<li>\n<p>함수 하나가 여러가지 일을 하게 만드는 것을 자제하자.</p>\n<ul>\n<li>물론 추상화는 위로 올라갈 수록 함수 하나가 여러가지 일을 해야한다.</li>\n<li>그렇다면 기능단위로 함수를 호출하여 글을 읽듯 내려갈 수 있게끔 간단하게 작성되어야 한다.</li>\n</ul>\n</li>\n</ul>\n<p>그냥 의식의 흐름대로 함수 하나에 쭉 때려박지 말자.<br>\n레거시 코드를 이해하지 못한다고 기존 코드에 신규 로직을 때려박지 말자.</p>\n<h1 id=\"dry-dont-repeat-yourself\"><a href=\"#dry-dont-repeat-yourself\" aria-label=\"dry dont repeat yourself permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DRY (Don't Repeat Yourself)</h1>\n<p>똑같은 코드, 동일한 로직을 반복해서 복붙하지 말라는 내용이다.</p>\n<p>쉽다. 하지만 실무에선 또 막상 해보자면 어렵다. 이게 뭔 개소리냐?</p>\n<p>동일한 로직에서 미묘하게 다른 경우가 있다. 물론 인자만 몇개 차이가 난다면 쉽게 함수화 할 수 있다.<br>\n하지만 커다란 로직 하나에 미묘한 몇가지 로직이 달라진다면? 그렇게 뺀 함수가 그렇게 보기좋은 모습도 아니라면?</p>\n<p>또, 반복되었다고 생각해서 뺐는데 생각해보니 이제 절대로 사용되지 않을 것 같은 로직이라면? 너무 번거롭지 않은가?</p>\n<p>개인적으로는 아래의 원칙을 지키고자 한다.</p>\n<ul>\n<li>다른 클래스 두개에서 동일한 로직을 쓴다면 그대로 쓴다. 두개까지는 가까운 시일 내에 변경사항이 한군데서만 있을 수 있기 때문.</li>\n<li>\n<p>세번의 반복이 있다면 여기서부터는 문제가 있다.</p>\n<ul>\n<li>클래스 단위로 반복이 있다면 상위 클래스를 만든다.</li>\n<li>로직 단위로 반복이 있다면 util 클래스로 뺀다.</li>\n</ul>\n</li>\n<li>만약 현재 한번만 사용되더라도 특정 클래스 내의 상태와 연관이 없고, 다른데서도 사용될 수 있을 법한 로직은 처음부터 util 로 뺀다.</li>\n</ul>\n<p>switch - case 등의 코드가 길어진다면 무작정 반복하지 않고 strategy 패턴을 적용한다.<br>\n(아직까지 이런 케이스에서는 몇번의 반복 이상이 디자인 패턴을 적용해서 이득을 볼 수 있을지 경험이 없기 때문에 시도는 안해봤다.)</p>\n<h1 id=\"yagni-you-arent-gonna-need-it\"><a href=\"#yagni-you-arent-gonna-need-it\" aria-label=\"yagni you arent gonna need it permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>YAGNI (You Aren’t Gonna Need It)</h1>\n<blockquote>\n<p>한번 설계 후 변경되기 어려운 DB 스키마나, 외부 노출용 API 에는 해당되지 않는다. 처음부터 잘짜는게 좋다.</p>\n</blockquote>\n<p>현재 필요하지도 않은 것을, 추후에 필요할 것이라 생각하고 미리 만들어두지 말라는 것이다.<br>\n하나 더 추가하여, 사용되지 않는 코드는 지워야 한다. 이는 클린코드에서 거론하는 이야기이다.</p>\n<p>전자는 쉬우나, 후자는 어렵다. 서비스의 규모가 늘어나면 늘어날 수록 이 코드가 진짜 아무데서도 쓰지 않는 건지 알기 어렵기 때문이다.</p>\n<p>덤으로, 우리 서비스는 각 프로젝트가 얽혀있어서 그냥 브라우저 window 에 객체를 박아두고 다른 프로젝트에서 이를 가져다 쓰는(!) 구조도 있다.<br>\n이런 구조에서는 이 함수가 현재 프로젝트의 어떤 곳에도 사용되지 않더라도 사용처가 있을 수 있다는 것이다.<br>\n물론 일반적인 프로젝트에선 이런 문제는 없겠지만..</p>\n<p>이 규칙이 중요한 것은 바로 개발은 <code>협업</code> 이기 때문이다.</p>\n<p>이 부분이 실제로 필요한지 아닌지는 지금 짠 내가 제일 잘 안다. 나는 이 부분이 왜 있는지 다른 팀원보다 쉽게 찾을 수 있기 때문에 5분이 걸린다고 생각해보자.<br>\n다른 팀원이 어떤 이슈를 처리하다가 이 코드를 본다면, 이 코드가 실제로 사용되는지 알기위해 처음부터 끝까지 로직을 살펴보아야 할 것이다.</p>\n<p>물론 이슈를 잘 처리하기위해 처음부터 끝까지 코드를 꼼꼼히 읽어 보는 것은 중요하지만, 매번 다른 팀원들이 그래야 할까?<br>\n그렇다면 그 부분을 더 어렵게 만들기 위해 내가 지금 사용되지도 않을 코드를 작성해야 할까?</p>\n<p>또한 이런 코드와 유사한 로직을 작성해야 한다면? 다른 팀원이 이 사용되지도 않던 코드가 있는줄 몰라서 또 다른 곳에 비슷한 로직을 작성했다면?</p>\n<p>코드는 점점 더 유지보수하기 어려운 상태가 될 것이고, 이슈를 처리하기 힘든 구역이 되어갈 것이다.</p>\n<p>당장 사용할 것이라면 구조를 고려해보자. 당장 필요하진 않다면 결합도를 높여두어도 된다.</p>\n<p><code>그때가면 더 좋은 코드가 생각날 것이고, 그 사이에 변경된 이슈때문에 그때에 맞는 작성방식이 있을 것이다.</code></p>\n<hr>\n<ul>\n<li>멋지고 힙한 코드보다는, 팀원이 읽기 좋은 코드를 짜야한다.\n그 코드는 나만 보는게 아니다. 이해를 못하게 작성했다면 팀원의 능력을 탓해선 안된다.</li>\n<li>리팩토링은 옳다. 하지만 신중해야한다. 내가 부족한 점이라 하면 이것이다.\n난 언제나 리팩토링을 하고자 하지만, 사소한 실수를 자주 하곤 한다. 그럼에도 도전하자.</li>\n<li>최적화는 더욱 신중해야한다. 최적화라고 코드를 건드는 순간 그 코드의 퍼포먼스는 재정의 된다.\n그게 더 좋아질수도, 안좋아질 수도 있다. 더 좋아진다 하더라도 큰 노력에 비해 너무나 적은 효과라면 다시 고려해 보는 것이 좋다.\n(나는 조금 더 빠른 코드보다는 조금 더 읽기 좋은 코드가 좋다. 생산성은 퍼포먼스가 아닌 유지보수하기 좋은 코드에서 빠른 이슈처리를 함으로서 나온다고 믿기 때문이다.)</li>\n</ul>","excerpt":"나는 개발을 하면서 몇가지 꼭 혼자서 지키고자 노력하는 원칙이 있다. 하나의 메소드는 15~20 줄이 넘어가지 않도록 하자. 세번의 반복로직은 하나의 함수로 인자는 모델 객체로 받거나, 3~…","fields":{"slug":"/2020/1/6/basic-programming-principal"},"frontmatter":{"id":"8861d370-3079-11ea-9922-e507e8961c54","title":"내가 생각하는, 좋은 코드를 작성하는 방법","slug":"/2020/1/6/basic-programming-principal","date":"2020-01-06T11:41:52.549Z","headerImage":""}},"previous":null,"next":null}]}},"pageContext":{"id":"2aab578d-1616-52bb-bb81-9cf3577cc077","index":0}}}