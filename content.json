{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/08/25/daily/hello-world/"},{"title":"TODO List","text":"언젠가 꼭 적을것Javascript basic 몽키패칭에 대하여 덕타이핑에 대하여 React Functional Component, Class Component, Pure Component and recompose library","link":"/2018/11/07/etc/todo/"},{"title":"몽키패치란","text":"몽키패치란프로그램의 런타임에서 그 구조를 변경하는 것을 몽키패치(Monkey Patch)라고 한다. 자바스크립트에서는 오브젝트의 prototype 을 변경하는 것을 뜻한다. 예를 들어, Array.prototype.push 가 있다고 하자.누군가가 이 함수가 호출될때 log 를 찍고 싶어서 push 함수를 직접 수정을 가했다. 그렇다면 모든 Array object 의 push 는 강제로 log 를 찍게 될 것이다. 이후 소스가 많이 수정되고나서 개발자가 바뀌었거나 다른 부분에서 로그를 없애려고 할때,유지보수측면에서 큰 문제가 발생할 수도 있다. 그러나 몽키패치를 좋은 예로서 사용한 부분이 바로 폴리필(Polyfill) 이다.폴리필은 크로스 브라우정을 위해 낮은 버전의 브라우저에서 지원되지 않는 함수를 작성한 코드 조각을 말한다. 이를 제외하고서는 개발상 몽키패치을 사용하고자 한다면 이는 안티패턴이라는 것을 알아야 한다. 참고 : NHN ENT. FE javascript anti-pattern","link":"/2018/11/11/dev/javascript/monkeypatch/"},{"title":"2019 네이버쇼핑 개발자 밋업을 다녀와서","text":"어떻게, 왜 갔나?https://festa.io/events/440 에서 주최한 네이버 쇼핑 개발자 밋업이었다.이전에 Glace CIC 에서 주최한 개발자 밋업을 먼저 들으러 갔었는데, 굉장히 인상깊었어서 네이버쇼핑의 개발 밋업도 기다리고 있는 찰나였다. 그런데 내가 확인했을 때는 이미 티켓이 매진된 상태여서… 개인적으로 이메일을 보내 가고싶다고 징징대서(…) 추가로 들을 기회를 얻을 수 있었다.두 밋업이 열린 메리츠타워는 커넥트재단과 Naver D2 Startup Factory 가 있는 곳이다. 내용은 어땠나?내가 Glace 와 네이버쇼핑 CIC 에 특히 관심이 있는 이유는 이 두 곳은 자바스크립트를 주력으로 사용하기 때문이다.물론 CIC 내 모든 팀이 그렇다고 확신할 수는 없지만.. 네이버는 아무래도 자바가 절대적으로 많이 쓰이는 회사인데 그 중에서도 모던 자바스크립트를 주로 활용하는 팀은 거의 없다.우리 팀 또한 풀 자바스크립트 개발스택을 가진 팀이기 때문에 아무래도 더 관심이 가는건 사실이다. Glace 에서 들었던 내용이 좋았던 탓인지 살짝 실망한 점도 없잖아 있었다. 내용은 아래와 같으며, 나의 역량이 부족해 완벽하게 이해하고 작성한건 아니라는 점을 먼저 적어둔다. 쇼핑검색 Java/JSP에서 Node.js/React 전환기(김득중) 어째서 Java/JSP(Spring) 에서 Node/React 환경으로 전환하였는가? 일단 유지보수하는데 문제는 없었으나 JSP 환경에 불만이 많았음. 자잘한 프론트 서스테이닝 및 그리드 수정 이슈가 간단한 이슈로 보이지만 코드의 양이 상당해,수정할 때마다 상당한 노력이 들어가야 했고, 그만큼 유지보수비용이 컸음. 그래서 이참에 신규도입을 하였는데, ES6 feature 들이 FE 데이터 다루기도 편해서 맘에 들었음. 전환하면서 좋은 구조를 위해 노력했던 점 프론트엔드의 구조를 컴포넌트 단위로 쪼개 분리하는 것이 우선 상태관리 도구로 Redux 를 선택했는데, Store 를 의사코드 작성부터 시작해서 잘 해둬야 한다.Store 데이터를 그때그때 추가하면서 나중에 정리가 되지 않으면 성능이슈가 발생할 수준으로 복잡해 질 수도 있음. 사족이라면, 우리도 비슷한 이슈가 있었는데 (물론 성능이슈가 발생한 것은 아니다)해당 리액트 컴포넌트는 스토어에서 필요한 값들만 구독해야 해당 값이 변할때만 리렌더를 진행할 것이다.하지만 초기에 어떤 값이 사용될지, 어떤 구조로 만들어졌는지 모른다고 store 객체를 spreading 해서 써버렸는데, 이후 다른 팀원 모두가 해당 컴포넌트의 구조를 따라 개발하면서 모든 객체가 store 값이 하나라도 바뀌면 전부 리렌더 중이었었다. 그래서 내가 전부 다 확인해서 바꿨다. 물론 문제는 발생했다. 신규 노드기반 서버가 request 처리량이 상당하게 떨어진 것 다른 과거 API 서비스 통신을 위한 xml 파싱이 문제였음 레거시 통신규약이기 때문에 안쓸수도 없고 마음대로 바꿀 수도 없는 부분 다양한 라이브러리를 확인해봤지만 다 느림. 빠르다는 node-expat 도 느리고.. easysax 라는 러시아산 xml 파싱라이브러리가 준나 빨랐음. 근데 그래도 느렸다 리액트로 작업하면서 Store 결과값이 포함된 페이지 response 가 내려가면서, 네트워크의 데이터량이 기존의 3~4배 스토어 데이터를 다시한번 가지치기 code minify 까지 했는데 이것도 그닥.. react-redux connect 의 mapStateToProps 에서 필요값만 구독 &gt; 유의미한 성능향상 모니터링은 어떻게 할까? pm2 오류로그가 상당해서 로그를 쏘는 라이브러리가 감당을 못하고 죽음-&gt; 프로세스 사망(uncaught exception) node -&gt; logServer 하지말고, node -&gt; fs write logs -&gt; filebeat 로 수정 기타 민감한 사항은 클라이언트 번들, 스토어에 추가되지 않도록 주의할것 스토어 크기는 최대한 줄이는 것이 좋다 gzip 압축을 꼭 하자 기왕 기술스택도 바꾸면서 PR 문화도 바꿔봤는데 PR 은 짧게, 자주하자 코드에 내 의견을 잔뜩 쓰자 채팅과 대화보다는 PR 을 draft 용으로 쓰는게 더 낫다 브라우저 날개를 달자 (이병승)경량화, 개선 대상에 대해서 알아보자 Network CDN 리소스 관리 http Protocol 2.0 프로토콜에서는 네트워크 리소스를 효율적으로 핸들링 할 수 있는 요소들이 꽤 있다. 동일 질의에 대한 브라우저 레벨 캐싱을 활용하자 Server Cache Async 로직 활용가능하다면. non-blocking logic 로직 자체의 효율성 DB lock, wait 내부 프로세스의 메커니즘 자체에 대한 이해. 물론 일반 개발자보단 DBA 분들 이야기 데이터 배치 쿼리. 아무래도 한번에 다몰리면 느리니까 쪼갤 수 있다면 잘 쪼개자 SQL 튜닝 브라우저(는 다 하면된다) 비동기 로직 컨트롤 non-blocking 로직 컨트롤 네트워크 트래픽 및 리소스 관리 Connection Count 렌더 최적화 몇가지 일화 소개 보이지도 않을 이미지가 무조건 먼저 로드되고 있어서 실제 의미있는 렌더 속도가 느려짐 다른 로직때문에 렌더링 동작이 블락되는 경우 requestAnimationFrame, requestIdleTimeout 을 활용 스크립트 로드가 당장 필요한 것이 아닌 경우면 비동기 로드 진행 &lt;script [async | defer] /&gt; UI 모듈화로 워라밸 지키기 (안정민) 쇼핑윈도우와 스마트스토어는 사실 다른 서비스이다 그런데 컴포넌트 마크업과 로직이 동일한 경우가 많았음 근데 내부 개발은 다르게 진행되면서 코드가 다르기 때문에 유지보수가 어려움 스펙 누락의 위험도 있었음 리액트 전환작업을 진행하면서 이참에 공통 컴포넌트 추출작업을 진행하였음 shopping, store, common 을 만듬 아래와 같은 경우에 따라 규칙을 정했음 마크업 같음, 상태관리 로직 같음 그냥 둘다 가져다 씀 마크업 같음, 상태관리 로직 다름 WrapperComponent 사용 props chain 이 필요한 경우는 React Context Provider 사용 마크업 다름, 상태관리 로직 같음 (버튼 생김새는 다르나 동일 결과를 부르는 경우) Class Component = HoC, FC = Custom Hooks 사실 WrapperComponent 와 어떤 부분이 다른지 잘 모르겠음 마크업 다름, 상태관리 로직 다름 그냥 각자 개발 장점 개발 리소스 절감 스펙변경시 유지보수 용이 작업대상 코드 서칭이 빠름 영양범위 파악하기 편함 단점 공통 모듈 수정은 사용서비스 모두에 영향이 감 UI 모듈이 늘어나면서 공통모듈 파악이 점점 어려워짐 이 부분은 Storybook 으로 기획/디자이너 협업을 도모 개발자가 좀 귀찮긴 한데 나중가면 비용이 덜 드는거라고 봄 갠적으로는 common 모듈의 위험성을 익히 들었기 때문에,이런 구조는 좀 더 개선되어야 하지 않을까 생각된다.common 을 가져다 쓰면, 아무 변경이 없더라도 wrapper 를 쓴다던가 해서 해당 프로젝트 내에는layer 단위로 무조건 한번 더 거쳐서 들어온다던가 하는 규약이 있다면 더 좋지 않았을까 싶다. React Hooks 마법. 그리고 깔끔한 사용기 (최효석) 좋은 코드란 간결하고, 로직의 예상이 쉬워야 하고, 사람이 읽기 쉬워야 하며, 재활용이 쉬워야 한다. React Hooks? FC 에서 state, lifecycle 사용을 가능하게 만들어주는 기능 Class Component 의 문제 DevTool &gt; Wrapper Hell common state 가 필요한 경우, HoC 가 당연시 lifecycle feature 간 로직 중복이 필요한 경우가 많다 componentDidMount 에서 getUserProfile() 하고나서componentDidUpdate 에서 또 getUserProfile() 이 작성되어야 한다던가 온,오프 이벤트 같이 관련된 로직이 다른 라이프사이클에 분산되어있어서 추적이 힘듬 상대적으로 js 기본기가 좀 더 좋아야 한다 FC with Hooks 장점 동일 라이프사이클이어도 로직을 쪼갤 수 있음 (multiple useEffect) useContext 로 globalVariable 존재 및 사용확정을 예측할 수 있음 단점 라이프사이클의 불명확 순서가 불명확함 Class Component 의 경우 리액트가 함수를 가져올 수 있는 주도권이 있음그러나 FC 는 실행시마다 hooks 관련 함수가 전부 실행됨 Hooks 실행 순서의 보장이 까다로움 useState 가 원하는 대로 데이터를 가져다 주지 않을 수 있음 eslint &gt; react-hooks, rulse-of-hooks 등의 린트 플러그인 활용 useEffect 잘쓰기 특정 props 가 변화할때만 부르게 짜두자 ( useEffect(fn, list of dependencies) ) 첫 render 에서만 불렸으면 하면 useEffect(fn, []) 휴식 후 세션은?자바스크립트 관련이 아니고, 내가 이해력이 부족해 잘 정리하지 못했다. 대략적인 내용으로는 Spring 5.0 의 WebFlux 를 쓸때는 blocking 함수를 자제하자 multiple server 에 configuration 배포 등 동일동작을 할때는 Ansible 을 고려해보자 k8s 에 노드 서버를 올릴때는 아래와 같은 고민을 하자 pm2 를 대체하여 k8s 기능들을 활용할 수 있을까? 클러스터링은 pods 롤 대체 restartPolicy 가 있으므로 죽은 프로세스 살리기도 가능 기타 pod 세팅으로 로깅이나 모니터링도 가능 하지만 pod 마다 로깅,모니터링 컨테이너가 있는 것도 비용이라는 것을 인지 pm2 의 노드 프로세스 셀프힐링보다 pod 이 내려갔다 올라오는게 훨씬 느리고 비용이 큼 느낀점 Glace 가 좀 더 자바스크립트 쪽으로 가신 느낌. 쇼핑은 풀스택 고수같은 주제들이었다. 자기가 안다고 생각 하는것과 어딘가에서 발표할때 많은 부분을 고려해서 설명하는건 확연히 다른데, 역시 고수들이라는 생각이 들었다. k8s 공부좀 해야겠다. 참고로 k8s pods 사이드카 컨테이너라고 한건 grafana 와 prometheus 이다. 우리 팀도 이번에 같은 사내플랫폼으로 도입했다.","link":"/2019/09/11/dev/seminar/2019-naver-shopping-meetup/"}],"tags":[{"name":"todo","slug":"todo","link":"/tags/todo/"}],"categories":[{"name":"Daily","slug":"Daily","link":"/categories/Daily/"},{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"dev","slug":"dev","link":"/categories/dev/"},{"name":"Dev","slug":"Dev","link":"/categories/Dev/"},{"name":"javascript","slug":"dev/javascript","link":"/categories/dev/javascript/"},{"name":"Seminar","slug":"Dev/Seminar","link":"/categories/Dev/Seminar/"},{"name":"javascript","slug":"Dev/javascript","link":"/categories/Dev/javascript/"},{"name":"Javascript","slug":"Dev/Javascript","link":"/categories/Dev/Javascript/"}]}